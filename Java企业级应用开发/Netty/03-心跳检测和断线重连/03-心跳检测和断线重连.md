# 心跳检测和断线重连

基于TCP的长连接服务器，为了时刻保持服务端到客户端在“传输层”这一抽象概念上的连通性，最常采用的是心跳包技术。当检测到连接意外断开，客户端需要主动尝试重连，恢复连接。如果最终无法连接，再做出相应的错误处理。

注：本篇笔记基于上一篇基于TCP的服务端和客户端代码。

## 心跳检测

一般来说，心跳包是由客户端定时发给服务端的，由服务端对客户端是否还在线做出判断。Netty中，心跳包具有三种类型的超时时间：

* 读超时：在规定时间内服务端没有从`Channel`读到数据，触发该超时
* 写超时：在规定时间内服务端没有向`Channel`写数据，触发该超时
* 读写超时：在规定时间内既没有从`Channel`读也没有向`Channel`写，触发该超时

`IdleStateHandler`这个处理器已经帮我们封装好了对三种超时方式的判断。

### 服务端超时处理器

下面服务端代码中，我们配置`IdleStateHandler`，设定三个超时时间参数，读超时5秒，写超时7秒，读写超时10秒。

TcpServerInitializer.java
```java
package com.ciyaz.demo.netty.tcp.server;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
import io.netty.handler.timeout.IdleStateHandler;
import io.netty.util.CharsetUtil;

import java.util.concurrent.TimeUnit;

/**
 * @author CiyaZ
 */
public class TcpServerInitializer extends ChannelInitializer<SocketChannel> {

    public static final int MAX_FRAME_LENGTH = 1024;
    private TcpServerHandler tcpServerHandler = new TcpServerHandler();

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        pipeline.addLast(new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, 0, 4, 0, 4));
        pipeline.addLast(new LengthFieldPrepender(4));
        pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
        pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
        pipeline.addLast(new IdleStateHandler(5, 7, 10, TimeUnit.SECONDS));
        pipeline.addLast(new IdleEventHandler());
        pipeline.addLast(tcpServerHandler);
    }
}
```

`IdleEventHandler`是我们自定义的一个处理器，它的作用是用来捕获超时事件。我们处理超时的逻辑很简单，将`Channel`断开即可。

IdleEventHandler.java
```java
package com.ciyaz.demo.netty.tcp.server;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.handler.timeout.IdleStateEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author CiyaZ
 */
public class IdleEventHandler extends ChannelInboundHandlerAdapter {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent idleStateEvent = (IdleStateEvent) evt;
            String evtType;
            switch (idleStateEvent.state()) {
                case READER_IDLE:
                    evtType = "读超时";
                    break;
                case WRITER_IDLE:
                    evtType = "写超时";
                    break;
                case ALL_IDLE:
                    evtType = "读写超时";
                    break;
                default:
                    evtType = "未知原因";
                    break;
            }
            ctx.channel().close();
            logger.info(ctx.channel().remoteAddress()+ " 通道关闭 " + evtType);
        }
    }
}
```

注意，这里我们继承的是`ChannelInboundHandlerAdapter`，这便于我们重写`userEventTriggered()`方法，上一步超时处理器会以传入事件的形式，回调该方法。我们可以通过读取方法的`evt`参数，得知超时事件的类型。

### 客户端实现定时心跳

客户端需要定时向服务端发送心跳包。实际上，对于这类需求，我们一般会基于TCP设计一套应用层协议，协议规定了通用的数据包报文格式，心跳包会作为报文的一种。我们这里简单起见，就不搞那么复杂了，直接发送一个字符串`heart beat`。

```java
private void pingServer(Channel channel) {
    // 发送心跳
    ScheduledFuture<?> future = channel.eventLoop().schedule(() -> {
        if (channel.isActive()) {
            // 通道仍连通，发送心跳
            // 这里只是测试，因此用字符串'heart beat'代表心跳包内容
            channel.writeAndFlush("heart beat");
        }
    },1,TimeUnit.SECONDS);
    future.addListener((GenericFutureListener) future1 -> {
        if (future.isSuccess()) {
            pingServer(channel);
        }
    });
}
```

代码可能和你想象的不太一样，我们没有单起一个线程，`sleep()`一段时间向`Channel`写一段数据。这是因为Netty中对很多操作做了封装。

`channel.eventLoop().schedule()`可以用来实现延迟调度，而`future`则是异步编程中用来绑定回调的一个对象。

```java
@Override
public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
    super.channelRegistered(ctx);
    // channel注册上时设置到对象成员变量，供输入接收线程使用
    channel = ctx.channel();

    pingServer(channel);
}
```

`pingServer()`方法在`Channel`注册时将首次调用。

### 客户端超时处理器

一般来说，服务端收到心跳包都会再响应一个心跳包，客户端如果很久都没收到来自服务端的任何响应，就要考虑自己是否是掉线了。

我们之前在服务端使用的`IdleStateHandler`也同样可以用于客户端，这里就不多介绍了。

## 断线重连

断线重连的逻辑主要还是由客户端实现的。当捕获到`Channel`未预期的突然关闭，或者发出的心跳包很久都没有收到响应，就要考虑重新和服务端建立连接。

当然，重连也是有一定策略的，最简单的策略：侦测到断线后，每隔5秒重试一次，共重试3次，如果仍不能重新建立连接，就把网络错误报告给用户。

