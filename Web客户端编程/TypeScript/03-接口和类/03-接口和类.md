# 接口

## TypeScript中接口的意义

TypeScript的接口相对于Java，具有更广泛的意义。TypeScript接口更像是一种数据对象类型的规定，而Java中更偏向于行为的描述，例子：

```javascript
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj)
```

TypeScript接口可以这样理解：

1. myObj对象有size属性和label属性，并传入printLabel()函数中。
2. 接口LabelledValue规定了这样一种对象：有一个属性是string类型。
3. printLabel定义了参数必须符合LabelledValue接口，即：拥有一个string类型的属性，myObj符合这种规定。
4. printLabel内，打印LabelledValue规定的string类型属性。

注意：

接口属性的定义没有顺序

## 可选属性

```javascript
interface SquareConfig {
  color?: string;
  width?: number;
}
```

使用“?”表示可选属性，可选属性可以不存在，使用可选属性的好处是对可能存在的属性进行预定义。

## 只读属性

```javascript
interface Point {
    readonly x: number;
    readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

只读属性不能修改，和const区别：属性使用readonly，变量使用const。

## 对象字面量的额外类型检查

```javascript
interface SquareConfig {
    color?: string;
    width?: number;
}
function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}
let mySquare = createSquare({ colour: "red", width: 100 });
```

传递给createSqure()函数的参数是对象字面量，这会产生额外的类型检查，由于接口中不存在colour属性，因此是无法通过编译的。

注：为什么会针对对象字面量做额外检查？因为按正常人的思维，参数类型都已经指定为接口类型了，对象字面量多余的字段根本就是无意义的，因此会报错。

以下三种方式能绕过这个问题：

### 使用类型断言

```javascript
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

### 使用字符串索引签名

```javascript
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

### 将这个对象赋值给另一个变量

```javascript
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

## 接口描述函数类型

```javascript
interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
```

调用签名指定了函数的参数类型和返回值类型。

## 接口描述可索引类型

```javascript
interface StringArray {
  [index: number]: string;
}
let myArray: StringArray;
myArray = ["Bob", "Fred"];
let myStr: string = myArray[0];
```

接口中使用了索引签名，表示用number索引，得到的是string类型。索引支持字符串和数字。

# 类

现代JavaScript使用函数式编程和基于对象的面向对象方式（而不是基于类的），这种方式是历史原因造成的，对于熟练使用Java/C++编程的程序员来说，这种编程方式需要额外的学习。TypeScript中的面向对象写法和传统语言更相似。

## 使用类

```javascript
class Student{
    private _studentName:string;
    constructor(studentName:string){
        this._studentName = studentName;
    }
    public get studentName(){
        return this._studentName;
    }
    public set studentName(newName:string){
        this._studentName = newName;
    }
    public say():void{
        console.log("hello, I am " + this._studentName);
    }
}
var tom:Student = new Student("Tom");
console.log(tom.studentName);
tom.studentName = "Tim";
tom.say();
```

基本和Java相同，类Student定义了一个string属性，一个构造器方法，一组set/get方法，一个say()方法。实例化类时，使用new关键字。this引用表示类的实例。

* 属性可以用private，public，protected修饰，但默认为public。构造器可以用public修饰，但没有意义。
* protected表示在该类的派生类中可以访问该属性。
* 可以指定readonly，使属性为只读。
* 存取器：set/get使用方法如上述代码，注意如果只有get没有set，该属性自动设置为只读，私有属性和存取器暴露的属性不能同名，例子中使用下划线`_studentName`表示私有属性
* static静态属性：和Java完全相同
* abstract抽象类：概念和Java完全相同，抽象方法必须包含abstract关键字和访问修饰符，必须在实现类中实现

编译运行上述代码

![](res/1.png)

注意：`--target ES6`，表示生成EcmaScript6标准的代码。

## 实现接口

类实现接口例子

```javascript
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}
class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```

和Java一样，接口描述了类的公共部分。接口之间可以继承，一个类可以实现多个接口。
