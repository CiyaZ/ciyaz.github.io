# 组件

Vue中可以封装组件以进行复用，这里介绍如何注册和编写Vue的组件。

## 注册全局的组件

下面是官网的例子，编写了一个按钮组件，每点击一次，按钮上的数字就会增加。

```javascript
//注册组件
Vue.component('button-counter', {
  data: function ()
  {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
});

//创建Vue对象
let app = new Vue({
  el: "#app",
  data: {},
  methods: {}
});
```

注册组件需要的参数和`new Vue`相同，都有`data`、`methods`、`computed`以及生命周期回调函数。但是，这里要注意的是`data`的写法是有区别的，组件定义中，`data`属性是一个函数，真正的数据作为函数的返回值对象，这是为了每个组件实例都能维护一份单独的数据拷贝，避免相同组件的不同实例之间的数据互相干扰。

编写组件时注意以下几点：

1. 注册组件的代码要写在创建Vue对象之前。
2. 自定义组件的`data`必须是一个函数，否则页面上所有相同组件中的数据都会被同步改变。
3. 切记，每个自定义组件的模板（template）中，必须只包含一个根元素，多个并列的元素是不行的。如果组件里确实包含多个并列的HTML标签，把它们用`<div>`包起来就行了。

```html
<div id="app">
  <button-counter></button-counter>
</div>
```

HTML代码中直接使用注册的组件名作为标签名就行了。

## 使用props向子组件传递数据

我们在HTML代码中使用组件时，通常需要向其传递数据，这是通过props实现的，使用方法如下。

```javascript
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
})
```

```html
<blog-post title="My journey with Vue"></blog-post>
```

如果我们需要向组件传递的数据不是一个简单的字符串，而是需要绑定到一个数据上，这时需要使用`v-bind`指令，将`data`中的数据绑定为HTML标签的属性。

例子：

```html
<body>
<div id="app">
	<blog-post v-bind:title="blogPost"></blog-post>
</div>
<script>
	Vue.component("blog-post", {
		props: ["title"],
		template: "<h3>{{ title }}</h3>"
	});
	let app = new Vue({
		el : "#app",
		data : {
			blogPost : "hello, world"
		}
	});
</script>
</body>
```

提示：`v-bind:title`可以简写为`:title`，在指令相关章节已经讲解过了。

## 使用`$emit`向父组件传递数据和触发事件

上面讲解和如何从父组件向子组件传递数据，这里再了解下如何从子组件向父组件传递数据。

下面例子中，实现子组件点击，通知父组件删除自身的功能。

```html
<body>
<div id="app">
	<input type="text" v-model="inputText"/>
	<button v-on:click="addTodo">提交</button>
	<div>
		todo
	</div>
	<ul>
		<todo-item v-bind:content="item" v-bind:index="index" v-for="(item, index) in todoList" v-on:delete="deleteTodo"></todo-item>
	</ul>
</div>
<script>
	Vue.component("TodoItem", {
		props : ["content", "index"],
		template : "<li v-text='content' v-on:click='handleClick'></li>",
		methods:{
			handleClick : function ()
			{
				this.$emit("delete", this.index);
			}
		}
	});
	let app = new Vue({
		el : "#app",
		data : {
			todoList : [],
			inputText : ""
		},
		methods : {
			addTodo : function ()
			{
				this.todoList.push(this.inputText);
				this.inputText = "";
			},
			deleteTodo :function (index)
			{
				this.todoList.splice(index, 1);
			}
		}
	});
</script>
</body>
```

子组件中，我们通过`this.$emit("事件名", 参数...)`触发了父组件的`delete`事件，并传递了参数`index`，父组件（app）通过`v-on:delete`接收了这个事件，并回调`deleteTodo`方法，获取到了`index`参数。

## slot插槽

模板中可以使用Vue定义的`<slot></slot>`标签，这在Vue中被称为“插槽”，自定义的组件中包含的文本会在插槽位置显示。

```javascript
Vue.component('test-component', {
  data: function () {},
  template: '<h1><slot></slot></h1>'
});
```

```html
<div id="app">
	<test-component>hello</test-component>
</div>
```

渲染后的HTML：
```html
<h1>hello</h1>
```

如果有多个插槽，可以使用`name`属性在`slot`上指定插槽名，模板中这样编写：

```html
<slot name="header"></slot>
```

HTML中可以用`template`标签把`slot`要插入的数据包裹起来，并使用`slot`属性标注slot的名字，代码如下：
```html
<template slot="header">
  Here might be a page title
</template>
```

## 注册非全局的子组件

我们用Vue构建的应用通常被称为SPA（单页Web应用），使用Vue的目的之一就是组件化，多个组件形成组件树，最终组件树的根节点就是整个应用。

下面例子演示了如何创建一个非全局的子组件：

```javascript
var componentB = Vue.component("component-b", {
  data: function () {},
  template: "<ul><li>1</li><li>2</li><li>3</li></ul>"
});

var componentA = Vue.component("component-a", {
  data: function () {},
  template: "<div><p>componentA</p><component-b></component-b></div>",
  components: {
    "component-b": componentB
  }
});
```

上面代码中，在componentA中套了一个componentB。
